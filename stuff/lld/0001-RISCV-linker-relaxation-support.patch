From 81a0428df9f9df74ff25ad733eb1ba55f93c79ea Mon Sep 17 00:00:00 2001
From: Ishimoto Shinobu <nagakamira@gmail.com>
Date: Thu, 31 Dec 2020 21:10:55 +0900
Subject: [PATCH] RISCV linker relaxation support

Signed-off-by: Ishimoto Shinobu <nagakamira@gmail.com>
---
 ELF/Arch/RISCV.cpp   | 128 ++++++++++++++++++++++++++++++++++++++++---
 ELF/InputSection.cpp | 101 ++++++++++++++++++++++++++++++++++
 ELF/InputSection.h   |  16 ++++++
 ELF/Relocations.cpp  |   4 +-
 ELF/Relocations.h    |   1 +
 ELF/Target.cpp       |   4 ++
 ELF/Target.h         |   4 ++
 ELF/Writer.cpp       |  31 ++++++++++-
 8 files changed, 277 insertions(+), 12 deletions(-)

diff --git a/ELF/Arch/RISCV.cpp b/ELF/Arch/RISCV.cpp
index b340fd0..726e68a 100644
--- a/ELF/Arch/RISCV.cpp
+++ b/ELF/Arch/RISCV.cpp
@@ -32,8 +32,8 @@ public:
   RelType getDynRel(RelType type) const override;
   RelExpr getRelExpr(RelType type, const Symbol &s,
                      const uint8_t *loc) const override;
-  void relocate(uint8_t *loc, const Relocation &rel,
-                uint64_t val) const override;
+  bool relaxSection(InputSection *isec, int pass) const override;
+  void relocate(uint8_t *loc, const Relocation &rel, uint64_t val) const override;
 };
 
 } // end anonymous namespace
@@ -51,6 +51,7 @@ enum Op {
 };
 
 enum Reg {
+  X_ZERO = 0,
   X_RA = 1,
   X_T0 = 5,
   X_T1 = 6,
@@ -58,6 +59,11 @@ enum Reg {
   X_T3 = 28,
 };
 
+enum RelaxPass {
+  PASS_OPT,
+  PASS_ALIGN,
+};
+
 static uint32_t hi20(uint32_t val) { return (val + 0x800) >> 12; }
 static uint32_t lo12(uint32_t val) { return val & 4095; }
 
@@ -71,6 +77,9 @@ static uint32_t utype(uint32_t op, uint32_t rd, uint32_t imm) {
   return op | (rd << 7) | (imm << 12);
 }
 
+const uint32_t nopInstr = itype(ADDI, X_ZERO, X_ZERO, 0);
+const uint16_t rvcNopInstr = 0x1;
+
 RISCV::RISCV() {
   copyRel = R_RISCV_COPY;
   noneRel = R_RISCV_NONE;
@@ -100,6 +109,8 @@ RISCV::RISCV() {
   pltHeaderSize = 32;
   pltEntrySize = 16;
   ipltEntrySize = 16;
+
+  relaxPasses = {PASS_OPT, PASS_ALIGN};
 }
 
 static uint32_t getEFlags(InputFile *f) {
@@ -236,16 +247,11 @@ RelExpr RISCV::getRelExpr(const RelType type, const Symbol &s,
   case R_RISCV_TPREL_LO12_I:
   case R_RISCV_TPREL_LO12_S:
     return R_TLS;
+  case R_RISCV_ALIGN:
+    return R_RISCV_RELAX_HINT;
   case R_RISCV_RELAX:
   case R_RISCV_TPREL_ADD:
     return R_NONE;
-  case R_RISCV_ALIGN:
-    // Not just a hint; always padded to the worst-case number of NOPs, so may
-    // not currently be aligned, and without linker relaxation support we can't
-    // delete NOPs to realign.
-    errorOrWarn(getErrorLocation(loc) + "relocation R_RISCV_ALIGN requires "
-                "unimplemented linker relaxation; recompile with -mno-relax");
-    return R_NONE;
   default:
     error(getErrorLocation(loc) + "unknown relocation (" + Twine(type) +
           ") against symbol " + toString(s));
@@ -437,6 +443,9 @@ void RISCV::relocate(uint8_t *loc, const Relocation &rel, uint64_t val) const {
     write64le(loc, val - dtpOffset);
     break;
 
+  case R_RISCV_ALIGN:
+    assert(config->relocatable);
+    return;
   case R_RISCV_RELAX:
     return; // Ignored (for now)
 
@@ -445,6 +454,107 @@ void RISCV::relocate(uint8_t *loc, const Relocation &rel, uint64_t val) const {
   }
 }
 
+static void relaxAlign(InputSection *isec, Relocation &rel,
+                       std::vector<std::pair<uint64_t, uint64_t>> &remove,
+                       uint64_t &removeTotal) {
+  // Addend is the number of bytes of nops currently present. The alignment
+  // required is therefore the next power of two bigger than this.
+  uint64_t align = NextPowerOf2(rel.addend);
+  uint64_t offset = rel.offset - removeTotal;
+  uint64_t aligned = alignTo(offset, align);
+  uint64_t requiredBytes = aligned - offset;
+  uint8_t *loc = isec->mutableData().data() + rel.offset;
+  if (requiredBytes > (uint64_t)rel.addend) {
+    errorOrWarn(getErrorLocation(loc) + "need " + Twine(requiredBytes) +
+                " bytes to align to " + Twine(align) +
+                "-byte boundary, but only " + Twine(rel.addend) + " present");
+    return;
+  }
+
+  // Delete relocation
+  rel.expr = R_NONE;
+
+  if (requiredBytes == (uint64_t)rel.addend)
+    return;
+
+  // Fill with nops
+  for (uint8_t *p = loc, *e = loc + requiredBytes; p + 3 < e; p += 4)
+    write32le(p, nopInstr);
+
+  // Write a single compressed nop if required
+  if (requiredBytes % 4 != 0) {
+    if (requiredBytes % 4 != 2) {
+      errorOrWarn(getErrorLocation(loc) + "need " + Twine(requiredBytes) +
+                  " bytes to align to " + Twine(align) +
+                  "-byte boundary, which is not an integral number of " +
+                  "instructions");
+      return;
+    } else if (!(config->eflags & EF_RISCV_RVC)) {
+      errorOrWarn(getErrorLocation(loc) + "need " + Twine(requiredBytes) +
+                  " bytes to align to " + Twine(align) +
+                  "-byte boundary, which requires a compressed nop, but " +
+                  "extension not present");
+      return;
+    }
+    write16le(loc + requiredBytes - 2, rvcNopInstr);
+  }
+
+  remove.emplace_back(rel.offset + requiredBytes, rel.addend - requiredBytes);
+  removeTotal += rel.addend - requiredBytes;
+}
+
+bool RISCV::relaxSection(InputSection *isec, int pass) const {
+  if (config->relocatable)
+    return false;
+
+  std::vector<std::pair<uint64_t, uint64_t>> remove;
+  uint64_t removeTotal = 0;
+  for (auto i = isec->relocations.begin(), e = isec->relocations.end(); i != e;
+       ++i) {
+    Relocation &rel = *i;
+    switch (pass) {
+    default:
+      llvm_unreachable("unknown relaxation pass");
+
+    case PASS_OPT: {
+      // Check if this is paired with an R_RISCV_RELAX
+      if (i + 1 == e || (i + 1)->type != R_RISCV_RELAX ||
+          rel.offset != (i + 1)->offset)
+        continue;
+
+      // Skip the R_RISCV_RELAX next time
+      ++i;
+
+      switch (rel.type) {
+      case R_RISCV_CALL:
+      case R_RISCV_CALL_PLT:
+        break;
+      }
+      break;
+    }
+
+    case PASS_ALIGN:
+      if (rel.type == R_RISCV_ALIGN)
+        relaxAlign(isec, rel, remove, removeTotal);
+      break;
+    }
+  }
+
+  auto brel = isec->relocations.begin();
+  auto dest = brel;
+  for (auto src = brel, erel = isec->relocations.end(); src != erel; ++src) {
+    if (src->expr != R_NONE)
+      *dest++ = *src;
+  }
+  isec->relocations.resize(dest - brel);
+
+  if (remove.size() == 0)
+    return false;
+
+  isec->deleteRanges(remove);
+  return true;
+}
+
 TargetInfo *elf::getRISCVTargetInfo() {
   static RISCV target;
   return &target;
diff --git a/ELF/InputSection.cpp b/ELF/InputSection.cpp
index a6c97a3..052345e 100644
--- a/ELF/InputSection.cpp
+++ b/ELF/InputSection.cpp
@@ -20,6 +20,7 @@
 #include "Thunks.h"
 #include "lld/Common/ErrorHandler.h"
 #include "lld/Common/Memory.h"
+#include "llvm/ADT/PriorityQueue.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/Compression.h"
 #include "llvm/Support/Endian.h"
@@ -838,6 +839,8 @@ uint64_t InputSectionBase::getRelocTargetVA(const InputFile *file, RelType type,
     return in.got->getTlsIndexOff() + a;
   case R_TLSLD_PC:
     return in.got->getTlsIndexVA() + a - p;
+  case R_RISCV_RELAX_HINT:
+    return 0;
   default:
     llvm_unreachable("invalid expression");
   }
@@ -1257,6 +1260,104 @@ void InputSection::replace(InputSection *other) {
   other->markDead();
 }
 
+void InputSection::makeMutableDataCopy() {
+  static std::mutex mu;
+  std::lock_guard<std::mutex> lock(mu);
+
+  ArrayRef<uint8_t> oldRef = data();
+  // In case the above just uncompressed
+  if (copiedData)
+    return;
+
+  size_t size = oldRef.size();
+  uint8_t *newData = bAlloc.Allocate<uint8_t>(size);
+  memcpy(newData, oldRef.data(), size);
+  rawData = makeArrayRef(newData, size);
+}
+
+void InputSection::deleteRanges(
+    std::vector<std::pair<uint64_t, uint64_t>> &ranges) {
+  // Delete bytes from data.
+
+  uint64_t removed = 0;
+  MutableArrayRef<uint8_t> mutRef = mutableData();
+  uint8_t *buf = mutRef.data();
+  size_t size = mutRef.size();
+  for (auto i = ranges.begin(), e = ranges.end(); i != e; ++i) {
+    uint8_t *moveTo = buf + (i->first - removed);
+    uint8_t *moveFrom = buf + i->first + i->second;
+    uint64_t nextOffset = i + 1 == e ? size : (i + 1)->first;
+    memmove(moveTo, moveFrom, nextOffset - i->first - i->second);
+    removed += i->second;
+  }
+  rawData = makeArrayRef(buf, size - removed);
+
+  // Update relocations; assumes already sorted.
+
+  auto irange = ranges.begin();
+  auto erange = ranges.end();
+  removed = 0;
+  for (Relocation &rel : relocations) {
+    while (irange != erange && irange->first < rel.offset) {
+      removed += irange->second;
+      ++irange;
+    }
+    rel.offset -= removed;
+  }
+
+  // Update symbols.
+
+  std::vector<Defined *> symbols;
+  for (Symbol *s : file->getSymbols())
+    if (auto *dr = dyn_cast<Defined>(s))
+      if (!dr->isSection() && dr->section == this)
+        symbols.push_back(dr);
+
+  llvm::sort(symbols,
+             [](Defined *a, Defined *b) { return a->value < b->value; });
+
+  using DefinedEndPair = std::pair<Defined *, uint64_t>;
+  auto compareEnds = [](DefinedEndPair &a, DefinedEndPair &b) {
+    uint64_t aend = a.first->value + a.second + a.first->size;
+    uint64_t bend = b.first->value + b.second + b.first->size;
+    return aend > bend;
+  };
+  PriorityQueue<DefinedEndPair, std::vector<DefinedEndPair>,
+                decltype(compareEnds)>
+      symbolEnds(compareEnds);
+
+  auto isym = symbols.begin();
+  auto esym = symbols.end();
+  irange = ranges.begin();
+  erange = ranges.end();
+  removed = 0;
+  while (isym != esym || irange != erange || !symbolEnds.empty()) {
+    while (irange != erange || !symbolEnds.empty()) {
+      // Adjust the size of any earlier symbols whose ends do not overlap with
+      // the current range.
+      if (isym != esym && irange != erange && irange->first >= (*isym)->value)
+        break;
+      while (!symbolEnds.empty()) {
+        auto top = symbolEnds.top();
+        uint64_t end = top.first->value + top.second + top.first->size;
+        if (irange != erange && end > irange->first)
+          break;
+        top.first->size -= removed - top.second;
+        symbolEnds.pop();
+      }
+      if (irange != erange) {
+        removed += irange->second;
+        ++irange;
+      }
+    }
+    if (isym != esym) {
+      (*isym)->value -= removed;
+      symbolEnds.emplace(*isym, removed);
+      ++isym;
+    }
+  }
+}
+
 template <class ELFT>
 EhInputSection::EhInputSection(ObjFile<ELFT> &f,
                                const typename ELFT::Shdr &header,
diff --git a/ELF/InputSection.h b/ELF/InputSection.h
index 112c6ab..f25dd8d 100644
--- a/ELF/InputSection.h
+++ b/ELF/InputSection.h
@@ -381,6 +381,15 @@ public:
   // Called by ICF to merge two input sections.
   void replace(InputSection *other);
 
+  MutableArrayRef<uint8_t> mutableData() {
+    if (!copiedData)
+      makeMutableDataCopy();
+    return llvm::makeMutableArrayRef(const_cast<uint8_t *>(rawData.data()),
+                                     rawData.size());
+  }
+
+  void deleteRanges(std::vector<std::pair<uint64_t, uint64_t>> &ranges);
+
   static InputSection discarded;
 
 private:
@@ -388,6 +397,13 @@ private:
   void copyRelocations(uint8_t *buf, llvm::ArrayRef<RelTy> rels);
 
   template <class ELFT> void copyShtGroup(uint8_t *buf);
+
+  void makeMutableDataCopy();
+
+  // This field stores whether we have made a mutable copy of the data, either
+  // because we have uncompressed it or because during relaxation we have had
+  // to rewrite the contents.
+  mutable bool copiedData = false;
 };
 
 inline bool isDebugSection(const InputSectionBase &sec) {
diff --git a/ELF/Relocations.cpp b/ELF/Relocations.cpp
index 751ded3..c7bd133 100644
--- a/ELF/Relocations.cpp
+++ b/ELF/Relocations.cpp
@@ -397,8 +397,8 @@ static bool isStaticLinkTimeConstant(RelExpr e, RelType type, const Symbol &sym,
             R_AARCH64_GOT_PAGE_PC, R_GOT_PC, R_GOTONLY_PC, R_GOTPLTONLY_PC,
             R_PLT_PC, R_TLSGD_GOT, R_TLSGD_GOTPLT, R_TLSGD_PC, R_PPC32_PLTREL,
             R_PPC64_CALL_PLT, R_PPC64_RELAX_TOC, R_RISCV_ADD, R_TLSDESC_CALL,
-            R_TLSDESC_PC, R_AARCH64_TLSDESC_PAGE, R_TLSLD_HINT, R_TLSIE_HINT>(
-          e))
+            R_TLSDESC_PC, R_AARCH64_TLSDESC_PAGE, R_TLSLD_HINT, R_TLSIE_HINT,
+            R_RISCV_RELAX_HINT>(e))
     return true;
 
   // These never do, except if the entire file is position dependent or if
diff --git a/ELF/Relocations.h b/ELF/Relocations.h
index ec59c63..ca215e8 100644
--- a/ELF/Relocations.h
+++ b/ELF/Relocations.h
@@ -98,6 +98,7 @@ enum RelExpr {
   R_PPC64_TOCBASE,
   R_RISCV_ADD,
   R_RISCV_PC_INDIRECT,
+  R_RISCV_RELAX_HINT,
 };
 
 // Architecture-neutral representation of relocation.
diff --git a/ELF/Target.cpp b/ELF/Target.cpp
index 6abd8b4..e05bace 100644
--- a/ELF/Target.cpp
+++ b/ELF/Target.cpp
@@ -180,6 +180,10 @@ void TargetInfo::relaxTlsLdToLe(uint8_t *loc, const Relocation &rel,
   llvm_unreachable("Should not have claimed to be relaxable");
 }
 
+bool TargetInfo::relaxSection(InputSection *isec, int pass) const {
+  llvm_unreachable("Should not have claimed to have relaxation passes");
+}
+
 uint64_t TargetInfo::getImageBase() const {
   // Use -image-base if set. Fall back to the target default if not.
   if (config->imageBase)
diff --git a/ELF/Target.h b/ELF/Target.h
index 47905ae..12df4c8 100644
--- a/ELF/Target.h
+++ b/ELF/Target.h
@@ -161,6 +161,10 @@ public:
   virtual void relaxTlsLdToLe(uint8_t *loc, const Relocation &rel,
                               uint64_t val) const;
 
+  llvm::SmallVector<int, 4> relaxPasses;
+
+  virtual bool relaxSection(InputSection *isec, int pass) const;
+
 protected:
   // On FreeBSD x86_64 the first page cannot be mmaped.
   // On Linux this is controlled by vm.mmap_min_addr. At least on some x86_64
diff --git a/ELF/Writer.cpp b/ELF/Writer.cpp
index b9fd03b..8b7b292 100644
--- a/ELF/Writer.cpp
+++ b/ELF/Writer.cpp
@@ -1746,6 +1746,33 @@ template <class ELFT> void Writer<ELFT>::finalizeAddressDependentContent() {
         warn("address (0x" + Twine::utohexstr(os->addr) + ") of section " +
              os->name + " is not a multiple of alignment (" +
              Twine(os->alignment) + ")");
+
+  // We cannot relax until after thunk creation has finished, since that causes
+  // code to increase in size and potentially invalidate some relaxations.
+  for (int pass : target->relaxPasses) {
+    assignPasses = 0;
+    for (;;) {
+      bool changed = false;
+      for (OutputSection *osec : outputSections)
+        for (InputSection *isec : getInputSections(osec))
+          changed |= target->relaxSection(isec, pass);
+
+      const Defined *changedSym = script->assignAddresses();
+      if (!changed) {
+        // Some symbols may be dependent on section addresses. When we break the
+        // loop, the symbol values are finalized because a previous
+        // assignAddresses() finalized section addresses.
+        if (!changedSym)
+          break;
+        if (++assignPasses == 5) {
+          errorOrWarn("assignment to symbol " + toString(*changedSym) +
+                      " does not converge after relaxation pass " +
+                      toString(pass));
+          break;
+        }
+      }
+    }
+  }
 }
 
 // If Input Sections have been shrinked (basic block sections) then
@@ -2139,7 +2166,9 @@ template <class ELFT> void Writer<ELFT>::finalizeSections() {
   //    address of InputSections. For example, MIPS GOT section content or
   //    android packed relocations sections content.
   //
-  // 3) Assign the final values for the linker script symbols. Linker scripts
+  // 3) Perform any linker relaxations that are address-dependent.
+  //
+  // 4) Assign the final values for the linker script symbols. Linker scripts
   //    sometimes using forward symbol declarations. We want to set the correct
   //    values. They also might change after adding the thunks.
   finalizeAddressDependentContent();
-- 
2.29.2

